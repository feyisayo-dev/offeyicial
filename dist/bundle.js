/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/call.js":
/*!********************!*\
  !*** ./js/call.js ***!
  \********************/
/***/ (() => {

eval("var localStream;\r\nvar remoteStream;\r\nvar localVideoElement = document.getElementById('local_video');\r\nvar remoteVideoElement = document.getElementById('remote_video');\r\nvar callTimerElement = document.getElementById('call_timer');\r\nvar callButton = document.getElementById('call_button');\r\nvar hangupButton = document.getElementById('hangup_button');\r\nvar audioCallButton = document.getElementById('audio_call_button');\r\nvar videoCallButton = document.getElementById('video_call_button');\r\nvar peerConnection; // Initialize the peerConnection variable here\r\nconst UserId = '<?php echo $UserId; ?>';\r\n\r\n// Event listeners for call buttons\r\naudioCallButton.addEventListener('click', startAudioCall);\r\nvideoCallButton.addEventListener('click', startVideoCall);\r\nhangupButton.addEventListener('click', hangUpCall);\r\n\r\nfunction startAudioCall() {\r\n    navigator.mediaDevices.getUserMedia({\r\n        audio: true\r\n    })\r\n        .then(function (stream) {\r\n            localStream = stream; // Assign the stream to localStream variable\r\n            // Create an instance of RTCPeerConnection\r\n            peerConnection = new RTCPeerConnection();\r\n            // Add the local audio stream to the peer connection\r\n            stream.getAudioTracks().forEach(function (track) {\r\n                peerConnection.addTrack(track, stream);\r\n            });\r\n\r\n            // Create and send a signaling message to the remote user\r\n\r\n            // Update the UI to reflect the call status\r\n            callButton.disabled = true;\r\n            hangupButton.disabled = false;\r\n            audioCallButton.disabled = true;\r\n            videoCallButton.disabled = true;\r\n        })\r\n        .catch(function (error) {\r\n            // Handle errors when accessing the user's microphone\r\n            console.log('Error accessing microphone:', error);\r\n        });\r\n}\r\n\r\nfunction startVideoCall() {\r\n    navigator.mediaDevices.getUserMedia({\r\n        video: true,\r\n        audio: true\r\n    })\r\n        .then(function (stream) {\r\n            localStream = stream; // Assign the stream to localStream variable\r\n            // Create an instance of RTCPeerConnection\r\n            peerConnection = new RTCPeerConnection();\r\n            // Add the local video and audio streams to the peer connection\r\n            stream.getTracks().forEach(function (track) {\r\n                peerConnection.addTrack(track, stream);\r\n            });\r\n\r\n            // Create and send a signaling message to the remote user\r\n\r\n            // Update the UI to reflect the call status\r\n            callButton.disabled = true;\r\n            hangupButton.disabled = false;\r\n            audioCallButton.disabled = true;\r\n            videoCallButton.disabled = true;\r\n\r\n            // Display the local video stream\r\n            localVideoElement.srcObject = stream;\r\n        })\r\n        .catch(function (error) {\r\n            // Handle errors when accessing the camera and microphone\r\n            console.log('Error accessing camera and microphone:', error);\r\n        });\r\n}\r\n\r\nfunction hangUpCall() {\r\n    // Stop the media streams\r\n    localStream.getTracks().forEach(function (track) {\r\n        track.stop();\r\n    });\r\n\r\n    // Close the RTCPeerConnection\r\n    if (peerConnection) {\r\n        peerConnection.close();\r\n        peerConnection = null;\r\n    }\r\n\r\n    // Send a \"call ended\" message to the remote user (using your signaling mechanism)\r\n    sendMessage('call-ended');\r\n\r\n    // Update the UI to reflect the call status\r\n    callButton.disabled = false;\r\n    hangupButton.disabled = true;\r\n    audioCallButton.disabled = false;\r\n    videoCallButton.disabled = false;\r\n    localVideoElement.srcObject = null;\r\n    remoteVideoElement.srcObject = null;\r\n    callTimerElement.textContent = '00:00:00';\r\n}\r\n\r\nfunction sendMessage(message) {\r\n    // Send the message to the remote user through your signaling mechanism\r\n    signalingSocket.send(JSON.stringify({\r\n        type: 'hangup',\r\n        message: 'call ended'\r\n    }));\r\n}\r\n\r\n// Functions to handle media streams\r\nfunction handleLocalStream(stream) {\r\n    localVideoElement.srcObject = stream;\r\n}\r\n\r\nfunction handleRemoteStream(stream) {\r\n    remoteVideoElement.srcObject = stream;\r\n}\r\n\r\n// Function to update the call timer\r\nfunction updateCallTimer(startTime) {\r\n    var currentTime = new Date();\r\n    var timeDiff = currentTime.getTime() - startTime.getTime();\r\n    var seconds = Math.floor(timeDiff / 1000);\r\n    var minutes = Math.floor(seconds / 60);\r\n    var hours = Math.floor(minutes / 60);\r\n    seconds %= 60;\r\n    minutes %= 60;\r\n    hours %= 24;\r\n\r\n    callTimerElement.textContent = hours.toString().padStart(2, '0') + ':' +\r\n        minutes.toString().padStart(2, '0') + ':' +\r\n        seconds.toString().padStart(2, '0');\r\n}\r\n\r\n// WebSocket connection\r\nvar signalingSocket;\r\n\r\nfunction initSignaling() {\r\n    var signalingServerUrl = 'localhost:8080'; // Replace with your signaling server URL\r\n\r\n    signalingSocket = new WebSocket(signalingServerUrl);\r\n\r\n    signalingSocket.onopen = function () {\r\n        console.log('Signaling socket connection established');\r\n    };\r\n\r\n    signalingSocket.onmessage = function (event) {\r\n        var message = JSON.parse(event.data);\r\n\r\n        if (message.type === 'offer') {\r\n            handleOfferMessage(message);\r\n        } else if (message.type === 'answer') {\r\n            handleAnswerMessage(message);\r\n        } else if (message.type === 'candidate') {\r\n            handleCandidateMessage(message);\r\n        } else if (message.type === 'hangup') {\r\n            handleHangupMessage(message);\r\n        }\r\n    };\r\n\r\n    signalingSocket.onclose = function (event) {\r\n        console.log('Signaling socket connection closed:', event.code, event.reason);\r\n        // Perform any necessary cleanup here\r\n    };\r\n\r\n    signalingSocket.onerror = function (error) {\r\n        console.log('Signaling socket error:', error);\r\n    };\r\n}\r\n\r\ninitSignaling();\r\n\n\n//# sourceURL=webpack:///./js/call.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/call.js"]();
/******/ 	
/******/ })()
;